<?php
/**
 * @file password_policy2.module
 * Enforce password security policies
 */

/**
 * Implements hook_menu().
 */
function password_policy2_menu() {
  // javascript callback 
  $items['password_policy2/check'] = array(
    'page callback' => 'password_policy2_ajax_check',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK, 
  );
  return $items;
}

function password_policy2_ajax_check() {
  $password = $_GET['password'];
  //using this user is not always going to work;
  global $user;
  $account = $user;
  password_policy2_user_load(array($account->uid=>$account));
  $policies = PasswordPolicy::matched_policies($account);
  $total = 0 ;
  $errors = array();
  foreach($policies as $policy) {

    $total += count($policy->message());
    $errors = $errors + $policy->constraint($password, $account);
  }
  $sus_count = $total - count($errors);

  $score = ($sus_count / $total) * 100;
  $msg = '';

  if(!empty($errors)) {
    $msg = theme('item_list', array('items' => $errors));
  }
  $return = array(
    'message' => $msg,
    'strength' => $score,
    'indicatorText' => "$sus_count of $total",
  );
  if($_GET['debug']) {
    return print_r($return, TRUE);
  }
  drupal_json_output($return);
}


/**
 * implements hook_ctools_plugin_type
 */
function password_policy2_ctools_plugin_type() {
  return array(
    'constraint' => array(
     'defaults' => array(
       'class' => 'PasswordPolicyConstraint',
      ),
    ),
    'condition'=>  array(
      'defaults' => array(
        'class' => 'PasswordPolicyCondition',
      ),
    ),
    'item'=>  array(
      'defaults' => array(
        'class' => 'PasswordPolicyItem',
      ),
    ),
  );
}

function password_policy2_ctools_plugin_directory($module, $plugin) {
  if ($module == 'password_policy2') {
   return "plugins/$plugin";
  }
  if ($module == 'ctools') {
   return "plugins/$plugin";
  }
}

function password_policy2_admin_settings(&$form, &$form_state) {
  $item = $form_state['item'];
  $policy = new PasswordPolicy($item);
  $form = $policy->admin_form($form, $form_state);
  $form_state['policy'] = $policy;
  return $form;
}

function password_policy2_admin_validate(&$form, &$form_state) {
  return TRUE;
}

function password_policy2_admin_submit(&$form, &$form_state) {
  $policy = $form_state['policy'];
  $policy->admin_form_submit($form, $form_state);
}


/**
 * implements hook_cron()
 */
function password_policy2_cron() {
  $policies = PasswordPolicy::all_policies();
  foreach($policies as $policy)  {
    $policy->cron();
  }
}
/**
 * implements hook_init()
 */
function password_policy2_init() {
 global $user;
 $policies = PasswordPolicy::matched_policies($user);
  foreach($policies as $policy)  {
    $policy->init($user);
  }
}


function password_policy2_password_element_alter(&$element, $account) {
 $policies = PasswordPolicy::matched_policies($account);
 $items = array();
 foreach($policies as $policy) {
   $items = $items + $policy->message();
 }
 $element['#description'] .= theme('item_list', array('items' => $items));
}
function password_policy2_form_user_profile_form_alter(&$form, $form_state) {
  password_policy2_password_element_alter($form['account']['pass'], $form['#user']);
  drupal_add_js(drupal_get_path("module", 'password_policy2') ."/password_policy2.js");
  $form['#validate'][] = 'password_policy2_user_profile_form_validate';
  $form['#submit'][] = 'password_policy2_password_submit';
}

function password_policy2_user_profile_form_validate($form, &$form_state) {
 if(!empty($form_state['values']['pass'])) {
   $account = $form['#user'];
   $policies = PasswordPolicy::matched_policies($account);
   $errors = array();
   foreach($policies as $policy) {
     $errors = $errors + $policy->constraint($form_state['values']['pass'], $account);
   }
   if(!empty($errors)) {
     form_set_error('pass', theme('item_list', array('items' => $errors)));
   }
  }
}

/**
 *  * Stores user password hash.
 *   *
 *    * @param $uid
 *     *   User id.
 *      * @param $pass
 *       *   Clear text password.
 *        */
function _password_policy2_store_password($uid, $pass, $do_not_hash=FALSE) {
  $history = (object) array(
    'uid' => $uid,
    'pass' => $do_not_hash ? $pass : user_hash_password($pass),
    'created' => time(),
    'data' => array(),
  );
  password_policy2_update_password_history($history);
}

/**
 * Implements hook_user_insert().
 */
function password_policy2_user_insert(&$edit, $account, $category) {
  if (!empty($edit['pass'])) {
    // New users do not yet have an uid during the validation step, but they do have at this insert step.
    // Store their first password in the system for use with the history constraint (if used).
    if ($account->uid) {
      _password_policy2_store_password($account->uid, $edit['pass']);
    }
  }
}


/**
 * Password save submit handler.
 */
function password_policy2_password_submit($form, &$form_state) {
  global $user;

  $values = $form_state['values'];
  $account = isset($form['#user']) ? $form['#user'] : (object)array('uid' => 0);

  // Track the hashed password values which can then be used in the history constraint.
  if ($account->uid && !empty($values['pass'])) {
    _password_policy2_store_password($account->uid, $values['pass']);
  }
}

/**
 *  implements hook_user_load
 *
 * add passwotd history to user
 *
 * used by past_password and expire plugins
 */
function password_policy2_user_load($accounts) {
  //insure all accounts have a histroy array
  foreach ($accounts as $account) {
    $account->password_history = array();
  }

  //pull history from db
  $query = db_select('password_policy2_history', 'p');
  $query
    ->condition('p.uid', array_keys($accounts))
    ->fields('p', array('uid', 'pass','created'))
    ->orderBy("created", "DESC");
  foreach ($query->execute() as $record) {
    $accounts[$record->uid]->password_history[] = $record;
  }
}

function password_policy2_update_password_history($history) {
  if(isset($hid)) {
    drupal_write_record('password_policy2_history', $history, 'hid');
  }
  else {
    drupal_write_record('password_policy2_history', $history);
  }
}


function password_policy2_token_info() {
$type = array(
  'name' => t('Password Expiration Date'), 
  'description' => t('Tokens related to expired passwords.'), 
  'needs-data' => 'password_expiration_date',
  );
  $formats = module_invoke_all("date_format_types");
  foreach($formats as $name=>$title) {
    $format[$name] = array(
      'name' => t("Expire Date @title Format", array('@title'=>$title)), 
      'description' => t("The Date the Password Expires in the #title Format.", array("@title"=>$title)),
    );
  }
    $format['interval'] = array(
      'name' => t("Expire Date interval"), 
      'description' => t("The Date the Password Expires in x days format"),
    );
  return array(
  'types' => array('password_expiration_date' => $type), 
  'tokens' => array('password_expiration_date' => $format),
  );
}
function password_policy2_tokens($type, $tokens, $data, $options) {
  if($type == 'password_expiration_date') {
    $replacements = array();
    foreach($tokens as $key => $token) {
      if ($key = 'interval') {
        $replacements[$token] = format_interval($data['password_expiration_date']-time());
        
      }
      else {
        $replacements[$token] = format_date($data['password_expiration_date'], $key);
      }
    }
    return $replacements;
  }
}


function password_policy2_mail($key, &$message, $params) {
  $language = $message['language'];
  $message['subject'] .= $params['subject'];
  $message['body'][] = $params['body'];
}

